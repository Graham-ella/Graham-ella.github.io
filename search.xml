<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22-07-16</title>
      <link href="/2022/07/16/%E6%9D%82%E9%A1%B9%E4%BB%A3%E7%A0%81/%E5%90%88%E5%B9%B6csv%E6%96%87%E4%BB%B6%E5%90%8C%E7%B1%BB%E9%A1%B9/"/>
      <url>/2022/07/16/%E6%9D%82%E9%A1%B9%E4%BB%A3%E7%A0%81/%E5%90%88%E5%B9%B6csv%E6%96%87%E4%BB%B6%E5%90%8C%E7%B1%BB%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> faker</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> Workbook</span><br><span class="line"><span class="keyword">from</span> openpyxl.styles <span class="keyword">import</span> Alignment</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csv_to_xlsx</span>():</span><br><span class="line">    <span class="comment"># csv = pd.read_csv(r&#x27;rawdatapy.csv&#x27;, encoding=&#x27;utf-8&#x27;)</span></span><br><span class="line">    <span class="comment"># csv.to_excel(r&#x27;rawdatapy.xlsx&#x27;, sheet_name=&#x27;data&#x27;)</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;rawdatapy.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        read = csv.reader(f)</span><br><span class="line">        wb = Workbook()</span><br><span class="line">        ws = wb.active</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> read:</span><br><span class="line">            ws.append(line)</span><br><span class="line">        wb.save(<span class="string">&#x27;rawdatapy.xlsx&#x27;</span>)  <span class="comment"># 保存Excel</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---将原始的csv文件转化为xlsx文件---&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xlsx_to_csv</span>():</span><br><span class="line">    <span class="comment"># df = pd.read_excel(&quot;rawdatapy.xlsx&quot;)</span></span><br><span class="line">    <span class="comment"># df.to_csv(&#x27;result.csv&#x27;)</span></span><br><span class="line">    ob = csv.writer(<span class="built_in">open</span>(<span class="string">&quot;result.csv&quot;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&quot;&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data = load_workbook(<span class="string">&#x27;rawdatapy.xlsx&#x27;</span>).active</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> data.rows:</span><br><span class="line">        row = [a.value <span class="keyword">for</span> a <span class="keyword">in</span> r]</span><br><span class="line">        ob.writerow(row)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;---成功将xlsx转化为csv文件---&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># a代表城市数量 b代表每个城市的街道数量 c代表的每个城市每个街道的每个数据(假设都是一样的)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">a=<span class="number">3</span>, b=<span class="number">20</span>, c=<span class="number">300</span></span>):</span><br><span class="line">    wb = Workbook()</span><br><span class="line">    my_sheet = wb.active</span><br><span class="line">    my_sheet.title = <span class="string">&quot;data&quot;</span></span><br><span class="line"></span><br><span class="line">    my_sheet.cell(<span class="number">1</span>, <span class="number">1</span>, <span class="built_in">str</span>(<span class="string">&quot;城市&quot;</span>))</span><br><span class="line">    my_sheet.cell(<span class="number">1</span>, <span class="number">2</span>, <span class="built_in">str</span>(<span class="string">&quot;街道&quot;</span>))</span><br><span class="line">    my_sheet.cell(<span class="number">1</span>, <span class="number">3</span>, <span class="built_in">str</span>(<span class="string">&quot;地址&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 产生数据时 保证城市名称不同 所有的街道名称互不相同</span></span><br><span class="line">    city_list = []</span><br><span class="line">    street_list = []</span><br><span class="line"></span><br><span class="line">    cnt = <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, a):</span><br><span class="line">        f = faker.Faker(locale=<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> city_list.count(f.city_name()) &gt; <span class="number">0</span>:</span><br><span class="line">            f = faker.Faker(locale=<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line">        city = f.city_name()</span><br><span class="line">        city_list.append(city)</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, b):</span><br><span class="line">            f = faker.Faker(locale=<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line">            <span class="keyword">while</span> street_list.count(f.street_name()) &gt; <span class="number">0</span>:</span><br><span class="line">                f = faker.Faker(locale=<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line">            street = f.street_name()</span><br><span class="line">            street_list.append(street)</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, c):</span><br><span class="line">                f = faker.Faker(locale=<span class="string">&#x27;zh_CN&#x27;</span>)</span><br><span class="line">                addr = f.address()</span><br><span class="line">                my_sheet.cell(row=cnt, column=<span class="number">1</span>, value=<span class="built_in">str</span>(city))</span><br><span class="line">                my_sheet.cell(row=cnt, column=<span class="number">2</span>, value=<span class="built_in">str</span>(street))</span><br><span class="line">                my_sheet.cell(row=cnt, column=<span class="number">3</span>, value=<span class="built_in">str</span>(addr))</span><br><span class="line">                cnt = cnt + <span class="number">1</span></span><br><span class="line">    wb.save(<span class="string">&quot;rawdatapy.xlsx&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;xlsx格式表格写入数据成功！&quot;</span>)</span><br><span class="line">    wb.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前多少列需要合并</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">num=<span class="number">2</span></span>):</span><br><span class="line">    wb1 = load_workbook(<span class="string">&quot;rawdatapy.xlsx&quot;</span>)</span><br><span class="line">    my_sheet = wb1.worksheets[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 获取行数</span></span><br><span class="line">    rows = my_sheet.max_row</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num+<span class="number">1</span>):</span><br><span class="line">        dict_from = &#123;&#125;</span><br><span class="line">        <span class="comment"># 行</span></span><br><span class="line">        <span class="keyword">for</span> ii <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, rows + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 读取数值</span></span><br><span class="line">            r = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="comment"># if i == 1:</span></span><br><span class="line">            r = <span class="built_in">str</span>(my_sheet.cell(ii, i).value)</span><br><span class="line">            <span class="comment"># if i == 2:  # 防止出现不同城市有相同的街道</span></span><br><span class="line">            <span class="comment">#     r = str(my_sheet.cell(ii, i-1).value) + str(my_sheet.cell(ii, i).value)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dict_from.get(r):</span><br><span class="line">                dict_from[r] = [i, ii, ii]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict_from[r][<span class="number">2</span>] = dict_from[r][<span class="number">2</span>] + <span class="number">1</span></span><br><span class="line">        dict_cross = &#123;<span class="number">1</span>: <span class="string">&#x27;A&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;B&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;C&#x27;</span>&#125;</span><br><span class="line">        <span class="comment"># print(dict_from)</span></span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> dict_from.items():</span><br><span class="line">            list_value0 = dict_cross[value[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="string">f&#x27;<span class="subst">&#123;list_value0&#125;</span><span class="subst">&#123;value[<span class="number">1</span>]&#125;</span>&#x27;</span> == <span class="string">f&#x27;<span class="subst">&#123;list_value0&#125;</span><span class="subst">&#123;value[<span class="number">2</span>]&#125;</span>&#x27;</span>):</span><br><span class="line">                <span class="comment"># print(f&#x27;&#123;list_value0&#125;&#123;value[1]&#125;:&#123;list_value0&#125;&#123;value[2]&#125;&#x27;)</span></span><br><span class="line">                my_sheet.merge_cells(<span class="string">f&#x27;<span class="subst">&#123;list_value0&#125;</span><span class="subst">&#123;value[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;list_value0&#125;</span><span class="subst">&#123;value[<span class="number">2</span>]&#125;</span>&#x27;</span>)</span><br><span class="line">                my_sheet[<span class="string">f&#x27;<span class="subst">&#123;list_value0&#125;</span><span class="subst">&#123;value[<span class="number">1</span>]&#125;</span>&#x27;</span>].alignment = Alignment(horizontal=<span class="string">&#x27;center&#x27;</span>, vertical=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line">                <span class="comment"># wb1.save(&quot;rawdatapy.xlsx&quot;)</span></span><br><span class="line"></span><br><span class="line">    wb1.save(<span class="string">&quot;rawdatapy.xlsx&quot;</span>)</span><br><span class="line">    wb1.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--合并结束finish--&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Press the green button in the gutter to run the script.</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># write_data()</span></span><br><span class="line">    <span class="comment"># print(&quot;get--data&quot;)</span></span><br><span class="line">    csv_to_xlsx()  <span class="comment"># 将输入的csv问价转化为同名的xlxs文件</span></span><br><span class="line">    read_data()  <span class="comment"># 读取数据后进行合并</span></span><br><span class="line">    xlsx_to_csv()  <span class="comment"># 将合并后的文件转化为csv的后缀</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 杂项代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-07-09</title>
      <link href="/2022/07/09/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-07-09/"/>
      <url>/2022/07/09/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-07-09/</url>
      
        <content type="html"><![CDATA[<h2 id="第四章-TCP-x2F-IP通信案例：访问Internet上的Web服务器"><a href="#第四章-TCP-x2F-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第四章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器"></a>第四章 TCP&#x2F;IP通信案例：访问Internet上的Web服务器</h2><h3 id="4-2-HTTP代理服务器的工作原理"><a href="#4-2-HTTP代理服务器的工作原理" class="headerlink" title="4.2 HTTP代理服务器的工作原理"></a>4.2 HTTP代理服务器的工作原理</h3><p>代理服务器按照其使用方式和作用，分为正向代理服务器、反向代理服务器和透明代理服务器。</p><p>正向代理服务器要求客户端自己配置代理服务器的地址，客户的每次请求都将直接发送到代理服务器，由代理服务器来请求目标资源，比如处于防火墙内的局域网机器想要访问Internet，或者访问一些屏蔽掉的国外网站，就是用的正向代理服务器。</p><p>反向代理服务器设置在服务器端，客户端不需要进行设置。反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。这种情况下，代理服务器对外表现为一个真实的服务器。</p><p>透明代理只能设置在网关上，用户访问Internet的数据报必然经过网关，在网关上设置代理对用户来说是透明的，透明代理可以看作是正向代理的一种特殊情况。</p>]]></content>
      
      
      <categories>
          
          <category> Linux高性能服务器阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-06-27</title>
      <link href="/2022/06/27/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-27/"/>
      <url>/2022/06/27/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-27/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><h3 id="3-4-TCP状态转移"><a href="#3-4-TCP状态转移" class="headerlink" title="3.4 TCP状态转移"></a>3.4 TCP状态转移</h3><h4 id="典型客户端的状态转移过程"><a href="#典型客户端的状态转移过程" class="headerlink" title="典型客户端的状态转移过程"></a>典型客户端的状态转移过程</h4><p>客户端通过connect系统调用主动与服务器建立连接，connect系统调用首先给服务器发送一个同步报文段，使得<br>连接转移到<b>SYN_SENT状态</b>。</p><p>connect系统调用可能因为如下两个原因失败：</p><ul><li>连接的目标端口不存在，或者被处于<b>TIME_WAIT状态</b>的连接占用，此时服务器将给客户端发送一个复位报文段，connect调用失败</li><li>目标端口存在，但connect在超时时间内未收到服务器的确认报文段，connect调用失败<br>如果connect调用失败，连接会返回初始的<b>CLOSED状态</b>，如果成功，连接转移到<b>ESTABLISHED状态</b></li></ul><p>客户端执行主动关闭时，它向服务器发送一个FIN，同时连接进入FIN_WAIT_1状态，如果收到了服务器的ACK，连接进入FIN_WAIT_2状态，此时服务器是出于CLOSE_WAIT状态，这一对状态是半关闭的状态，如果收到服务器的FIN，ACK（其实主要是FIN），客户端发送ACK后进入TIME_WAIT状态。</p><p>如果想要直接从FIN_WAIT_1进入到TIME_WAIT状态，需要客户端直接收到带有确认信息的FIN报文段，不能写收到确认报文段，再收到FIN结束报文段。</p><p>处于FIN_WAIT_2状态的客户端需要等待服务器的FIN的报文段，才能转移到TIME_WAIT状态，连续停留在FIN_WAIT_2状态的情况可能发生在：客户端执行半关闭后，未等服务器关闭连接就强行推出了，此时的客户端连接由内核接管，这种称为<b>孤儿连接</b>。Linux为了防止孤儿连接长时间存留在内核中，定义了两个内核变量：</p><ul><li>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_orphans 内核能接管的孤儿连接数量</li><li>&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fin_timeout 孤儿连接在内核的存活时间</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/origin_img_v2_63c5be98-e239-4941-9b9d-38ec212c04ag.jpg" alt="状态示意图"></p><h4 id="time-wait状态"><a href="#time-wait状态" class="headerlink" title="time_wait状态"></a>time_wait状态</h4><p>如上图所示，客户端收到服务器的FIN后进入了TIME_WAIT状态，客户端连接要等待2MSL的时间才能完全关闭。<br>这状态存在的原因有：</p><ul><li>可靠的中止TCP连接<br>如果客户端最后回复的ACK丢失了，服务器会重发FIN，客户端需要停留在某个状态重新发ACK</li><li>保证让迟来的TCP报文有足够的时间被识别和丢弃<br>当一个TCP连接处于TIME_WAIT状态，我们无法用它的端口来建立一个新连接，如果不存在TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似的连接，那么这个新的<br>连接可能会受到网络中旧的报文段，这样就可以清干净网络</li></ul><p>如下图所示，可能出现端口被占用的情况<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220627152651.png" alt="立刻重启"></p><p>不过，一般来说客户端的端口号一般是系统临时分配的自动端口号，但是如果是服务器主动关闭连接，因为它对于一些知名服务都是用的同一些端口号，TIME_WAIT状态会让他不能立即重启，我们可以通过socket选项SO_REUSEADDR来强制进程使用被TIME_WAIT连接占用的端口号</p><h3 id="3-5-复位报文段"><a href="#3-5-复位报文段" class="headerlink" title="3.5 复位报文段"></a>3.5 复位报文段</h3><p>复位报文段：携带RST标志，通知对方关闭连接或者重新建立连接。</p><h4 id="端口问题"><a href="#端口问题" class="headerlink" title="端口问题"></a>端口问题</h4><p>尝试连接到端口不存在或者该端口仍然被处于TIME_WAIT状态的连接所占用，这里的端口指的是服务器端口</p><h4 id="异常终止连接"><a href="#异常终止连接" class="headerlink" title="异常终止连接"></a>异常终止连接</h4><p>TCP提供了异常中止连接的方法：给对方发送一个复位报文段，发送端所有排队等待发送的数据会被丢弃，<br>可以使用socket的SO_LINGER来发送复位报文段</p><h4 id="处理半打开连接"><a href="#处理半打开连接" class="headerlink" title="处理半打开连接"></a>处理半打开连接</h4><p>什么是半打开连接？ 客户端：C 服务器端：S<br>如果S中途异常中止了连接，此时C没有收到S的FIN，还会维持之前的连接，此时对于C来说这个连接就处于半打开状态</p><p>其实这里就是说，在上面的场景中，如果S重新投入工作，C还给S发送数据的话，S就会返回带RST标识的报文段</p><h3 id="3-6-3-7-TCP数据流"><a href="#3-6-3-7-TCP数据流" class="headerlink" title="3.6-3.7 TCP数据流"></a>3.6-3.7 TCP数据流</h3><p>TCP数据流主要分成两种：交互数据流和成块数据流，前者携带的字节数少，对实时性要求比较高，后者携带数据多，对传输效率要求高</p><h4 id="交互数据流"><a href="#交互数据流" class="headerlink" title="交互数据流"></a>交互数据流</h4><p>延迟确认：不立刻发送ACK，等自己有数据要发了，一起发过去，这样有效减少发送的TCP报文段数量</p><p>由于这些交互用的TCP报文段携带的数据很少，因此引入了Nagle算法<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220627213032.png" alt="Nagle算法"></p><h4 id="成块数据流"><a href="#成块数据流" class="headerlink" title="成块数据流"></a>成块数据流</h4><p>当传输大量数据时，发送方可以一次性发送多个报文段，接收方可以一次确认多个，<br>发送方通过ack中的<b>接收窗口大小</b>和<b>窗口扩大因子</b>计算接收方缓冲区的容量来判断自己还能发多少</p><h3 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h3><p>带外数据就是需要紧急发出去的数据，UDP不支持，TCP通过标志位来实现（头部的紧急指针标志和紧急指针）</p><h3 id="3-9-TCP超时重传"><a href="#3-9-TCP超时重传" class="headerlink" title="3.9 TCP超时重传"></a>3.9 TCP超时重传</h3><p>重传其实就是你发送一个报文段，结果很久都没有收到ACK，你在发送的时候会设置一个定时器，一旦超时了你就重传，并且重置这个定时器，至于说你重传几次，下一次的超时时间设定都是你重传策略自己设置的</p><p>前者指定在底层IP接管之前TCP最少执行的重传次数，默认是3；后者指定连接放弃前TCP最多可以执行的重传次数，默认值是15；</p><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220627215607.png" alt="超时重传参数查看"></p><h3 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h3><p>非常简单，其实就是你发送的数据大小是由接收窗口的RWND和发送窗口的最小值来决定的，发送窗口的大小是由拥塞控制算法来控制，至于慢启动、拥塞避免、快速重传、快速恢复之前已经整理过了，这里不多解释了</p>]]></content>
      
      
      <categories>
          
          <category> Linux高性能服务器阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第81场双周赛</title>
      <link href="/2022/06/26/leetcode%E5%91%A8%E8%B5%9B/leetcode%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/06/26/leetcode%E5%91%A8%E8%B5%9B/leetcode%E7%AC%AC81%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="lc6104-统计星号"><a href="#lc6104-统计星号" class="headerlink" title="lc6104. 统计星号"></a><a href="https://leetcode.cn/problems/count-asterisks">lc6104. 统计星号</a></h2><p>自己一开始写的版本太墨迹了—-</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countAsterisks</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; cnt % <span class="number">2</span> == <span class="number">0</span>) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc6106-统计无向图中无法互相到达点对数"><a href="#lc6106-统计无向图中无法互相到达点对数" class="headerlink" title="lc6106. 统计无向图中无法互相到达点对数"></a><a href="https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph">lc6106. 统计无向图中无法互相到达点对数</a></h2><p>并查集来做，维护每个集合的点的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">200010</span>], ssize[<span class="number">200010</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == f[x]) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">countPairs</span><span class="params">(<span class="type">int</span> n, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">            ssize[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; c: edges)&#123;</span><br><span class="line">            <span class="type">int</span> a = <span class="built_in">find</span>(c[<span class="number">0</span>]), b = <span class="built_in">find</span>(c[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                <span class="comment">// 如果两个不在一起</span></span><br><span class="line">                f[b] = a;</span><br><span class="line">                ssize[a] += ssize[b];    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1ll</span> * n * (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i] == i)&#123;</span><br><span class="line">                res = res - <span class="number">1ll</span> * ssize[i] * (ssize[i] - <span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc6105-操作后的最大异或和"><a href="#lc6105-操作后的最大异或和" class="headerlink" title="lc6105. 操作后的最大异或和"></a><a href="https://leetcode.cn/problems/maximum-xor-after-operations">lc6105. 操作后的最大异或和</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">位运算特殊的地方在于: 数位之间是独立的</span></span><br><span class="line"><span class="comment">当我们想用数x来更新nums[i]的某一位时，如果这位是0，发现按照它的运算规则，这个数永远是0；</span></span><br><span class="line"><span class="comment">如果这个数是1， 那么根据x这一位的情况，可能修改为0或者还是1</span></span><br><span class="line"><span class="comment">因此，nums中的所有数如果某一位置都是0，那么最终结果只能是0了，否则就可以变成1，因此</span></span><br><span class="line"><span class="comment">只要把所有数按位或起来即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximumXOR</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; c: nums)&#123;</span><br><span class="line">            res |= c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc6107-不同骰子序列的数目"><a href="#lc6107-不同骰子序列的数目" class="headerlink" title="lc6107. 不同骰子序列的数目"></a><a href="https://leetcode.cn/problems/number-of-distinct-roll-sequences">lc6107. 不同骰子序列的数目</a></h2><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/origin_img_v2_db729c7b-0555-4307-9e4d-ceccc231542g.jpg" alt="题目解析"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="comment">// f[n][j][k]代表抛的次数为n最后两次分别是j和k的可行序列个数</span></span><br><span class="line"><span class="comment">// f[n][j][k]是各个f[n-1][u][j]的和，u在[0-5]间，不过要满足对应条件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> f[N][<span class="number">6</span>][<span class="number">6</span>]; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">distinctSequences</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; <span class="built_in">gcd</span>(i + <span class="number">1</span>, j + <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                    f[<span class="number">2</span>][i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m = <span class="number">3</span>; m &lt;= n; m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i != j &amp;&amp; <span class="built_in">gcd</span>(i + <span class="number">1</span>, j + <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> u = <span class="number">0</span>; u &lt; <span class="number">6</span>; u++)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(u != i &amp;&amp; u != j &amp;&amp; <span class="built_in">gcd</span>(u + <span class="number">1</span>, i + <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                                f[m][i][j] = (f[m][i][j] + f[m - <span class="number">1</span>][u][i]) % MOD;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">                res = (res + f[n][i][j]) % MOD;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lc周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-06-26</title>
      <link href="/2022/06/26/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-26/"/>
      <url>/2022/06/26/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-26/</url>
      
        <content type="html"><![CDATA[<h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><h3 id="3-4-TCP状态转移"><a href="#3-4-TCP状态转移" class="headerlink" title="3.4 TCP状态转移"></a>3.4 TCP状态转移</h3><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220626230259.png" alt="TCP状态转移图"></p><h4 id="典型服务器端的状态转移过程："><a href="#典型服务器端的状态转移过程：" class="headerlink" title="典型服务器端的状态转移过程："></a>典型服务器端的状态转移过程：</h4><p>服务器通过listen系统调用进入<b>LISTEN状态</b>，被动等待客户端连接，执行的是所谓的被动打开，服务器一旦监听到某个连接请求，就将该连接放入内核等待队列中，并<br>向客户端发送带SYN标志的确认报文段，此时该连接处于了<b>SYN_RCVD状态</b>。如果服务器成功接收到客户端发来的确认报文，该连接转移到<b>ESTABLISHED状态</b>。ESTABLISHED状态是连接双方能够进行双向数据传输的状态。</p><p>当客户端主动关闭连接时（通过close或者shutdown系统调用发送结束报文段），服务器通过返回确认报文段使连接进入<b>CLOSE_WAIT状态</b>，等待服务器应用程序关闭连<br>接。通常服务器检测到客户端关闭连接后，也会立即给客户端发送一个结束报文段来关闭连接。这将使连接转移到<b>LAST_ACK状态</b>，以等待客户端对结束报文段的最后一次确认。一旦确认完成，连接关闭。</p>]]></content>
      
      
      <categories>
          
          <category> Linux高性能服务器阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0624题目</title>
      <link href="/2022/06/24/acw%E9%A2%98%E7%9B%AE/0624%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/06/24/acw%E9%A2%98%E7%9B%AE/0624%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="笛卡尔树"><a href="#笛卡尔树" class="headerlink" title="笛卡尔树"></a>笛卡尔树</h2><p><b>堆不一定要是完全二叉树，只不过完全二叉树建堆更方便</b><br>这里显然整个树的根应该是最下的值，然后由于要求中序遍历的结果和原数组一致，<br>所以相当于递归的感觉，把中间的root排除了，左右两边分别构建树<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624172207.png" alt="题目分析"></p><p>代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> val[N], L[N], R[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l + <span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span>(val[i] &lt; val[res]) res = i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建笛卡尔树的过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span> <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">if</span>(l == r) <span class="keyword">return</span> l;</span><br><span class="line">    <span class="type">int</span> root_index = <span class="built_in">getMin</span>(l, r);</span><br><span class="line">    L[root_index] = <span class="built_in">dfs</span>(l, root_index - <span class="number">1</span>);</span><br><span class="line">    R[root_index] = <span class="built_in">dfs</span>(root_index + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> root_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(L, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> L);</span><br><span class="line">    <span class="built_in">memset</span>(R, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> R);</span><br><span class="line">    cin &gt;&gt; n; <span class="comment">// 读入长度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val + i); <span class="comment">// 读入每个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root_index = <span class="built_in">dfs</span>(<span class="number">0</span>, n - <span class="number">1</span>); <span class="comment">// 构建完树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出层序遍历</span></span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = root_index;</span><br><span class="line">    <span class="comment">// q[0] = 4;</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh];</span><br><span class="line">        cout &lt;&lt; val[t] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        hh++;</span><br><span class="line">        <span class="keyword">if</span>(L[t] != inf) q[++tt] = L[t];</span><br><span class="line">        <span class="keyword">if</span>(R[t] != inf) q[++tt] = R[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以直接在建立树的过程中就保存每一层的节点，代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> val[N];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dd</span>(N); <span class="comment">// 代表N层</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l+<span class="number">1</span>; i &lt;= r; i++)</span><br><span class="line">        <span class="keyword">if</span>(val[i] &lt; val[res]) res = i;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt; r) <span class="keyword">return</span>; <span class="comment">// 非常重要</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        dd[d].<span class="built_in">push_back</span>(val[l]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> root = <span class="built_in">getMin</span>(l, r);</span><br><span class="line">    dd[d].<span class="built_in">push_back</span>(val[root]);</span><br><span class="line">    <span class="built_in">dfs</span>(l, root - <span class="number">1</span>, d + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">dfs</span>(root + <span class="number">1</span>, r, d + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, val + i);</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; dd[i].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            cout &lt;&lt; dd[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-06-24</title>
      <link href="/2022/06/24/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-24/"/>
      <url>/2022/06/24/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-24/</url>
      
        <content type="html"><![CDATA[<h2 id="第二章-ip协议详解"><a href="#第二章-ip协议详解" class="headerlink" title="第二章 ip协议详解"></a>第二章 ip协议详解</h2><h3 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h3><ul><li>IP协议是无状态的，通信双方不长久的维护双方的信息</li><li>不可靠: 不能保证IP数据包可以准确的到达接收端，中转路由器和接收端都有可能因为某些原因抛弃数据包，然后返回ICMP错误消息</li></ul><h3 id="2-2-ipv4头部结构"><a href="#2-2-ipv4头部结构" class="headerlink" title="2.2 ipv4头部结构"></a>2.2 ipv4头部结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624111910.png" alt="ipv4头部"><br>注意:</p><ul><li>头部长度的单位是4字节 因此头部最大为60字节</li><li>8位服务类型：3位是优先段字段（已废弃）、4位TOS字段（最小延时、最大吞吐量、最高可靠性、最小费用）</li><li>16位总长度指的是整个IP数据报的长度</li><li>16位标识唯一标识主机发送的每个数据包，初始值随机生成，注意一个数据包的所有分片都具有相同的标识</li><li>13位片偏移:分片相对原始IP数据报开始处的（仅仅指数据部分）的偏移，实际偏移值要乘以8</li><li>8位协议是用来区分上层的协议，&#x2F;etc&#x2F;protocols可以查看数值 TCP是6 UDP是17 ICMP是1</li><li>可变长的可选信息：头部固定大小有20字节，最大头部是60字节，因此可选最大是40字节（作用是可以记录下自己经过的路由器IP、时间戳之类的东西）</li></ul><h3 id="2-3-ip分片"><a href="#2-3-ip分片" class="headerlink" title="2.3 ip分片"></a>2.3 ip分片</h3><p>其实就是受限于MTU，如果MTU是1500字节，意味着整个IP数据包的长度就是1500字节，由于固定的首部大小为20字节，理论上能传输的最大有效数据也就是1480字节，<br>不够只能选择分片</p><h3 id="2-4-ip路由"><a href="#2-4-ip路由" class="headerlink" title="2.4 ip路由"></a>2.4 ip路由</h3><p>略</p><h3 id="2-5-ip转发"><a href="#2-5-ip转发" class="headerlink" title="2.5 ip转发"></a>2.5 ip转发</h3><p>主机一般负责发送和接收数据报，因为主机上 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_forward的内核参数默认被设置为0，我们可以通过修改它来使能主机的数据报转发功能<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624123954.png"></p><h3 id="2-6-重定向"><a href="#2-6-重定向" class="headerlink" title="2.6 重定向"></a>2.6 重定向</h3><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624124313.png"></p><h3 id="2-7-ipv6头部结构"><a href="#2-7-ipv6头部结构" class="headerlink" title="2.7 ipv6头部结构"></a>2.7 ipv6头部结构</h3><p>ipv6的作用:(16个字节 128位)</p><ul><li>解决了ipv4地址不够用的问题</li><li>增加了多播和流的功能，为网络上多媒体内容的质量提供了精细的控制</li><li>引入自动配置功能，使得局域网管理更方便</li><li>增加了专门的网络安全功能</li></ul><p>ipv6地址用”:”这样的表示方法，而且可以省略连续的、全零的组，称为零压缩法，但是零压缩法<br>对一个ipv6地址只能使用一次，用”::”表示省略</p><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624140501.png" alt="ipv6扩展头部"></p><h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><h3 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h3><p>TCP协议的连接是一对一的，基于广播和多播的应用程序不能使用TCP服务，UDP协议更加适合；<br>TCP是字节流服务的，意味着TCP模块发出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系，<br>应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的关系。<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624143728.png" alt="字节流服务和数据报服务"></p><h3 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624143937.png" alt="TCP头部"></p><ul><li>端口号：进行TCP通信的时候，客户端通常使用系统自动临时选择的端口号，而服务器端使用知名服务端口号，可以通过&#x2F;etc&#x2F;services来查询;</li><li>16位窗口大小：TCP流量控制的手段，RWND（接收通告窗口），告诉TCP接收缓冲区还能容纳多少字节的数据，这样就可以控制发送的速度</li></ul><p><img src="/../../../linkpages/TCP%E6%89%A9%E5%B1%95%E5%AD%97%E6%AE%B5.png" alt="TCP扩展字段"></p><h3 id="3-3-TCP连接的建立和关闭"><a href="#3-3-TCP连接的建立和关闭" class="headerlink" title="3.3 TCP连接的建立和关闭"></a>3.3 TCP连接的建立和关闭</h3><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624212303.png" alt="TCP连接建立和关闭示意图"></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手建立连接的第一个TCP报文段包含SYN标志，它是一个同步报文段，第二个也是，同步报文段特殊的地方在于虽然它不携带应用程序的数据，<br>它也要占用一个序号值，<br>因此，如果A和B建立连接，A一开始的序列号seq &#x3D; x，B返回的ack就是x + 1，代表下一次它想要x+1, B返回的序列号如果是y，那么第三次握手<br>A的ack应该是y + 1</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手这里想的是第二次挥手有无作用，实际上它仅仅是一个确认目的，是可以省略的，因为第三次挥手也携带了确认信息，是否需要它取决于<br>TCP的延迟确认特性</p><h4 id="连接建立和断开总结"><a href="#连接建立和断开总结" class="headerlink" title="连接建立和断开总结"></a>连接建立和断开总结</h4><p>一般来说，TCP连接是由客户端发起的，通过三次握手建立连接，TCP连接关闭的过程相对复杂，可能是客户端主动执行关闭，可能是服务器执行主动关闭（服务程序中断强行关闭程序），也可能是同时关闭</p><h4 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h4><p>TCP连接是全双工的，支持两个方向的通信的数据传输独立关闭，此时称为半关闭状态<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624225033.png" alt="半关闭状态"><br>相当于客户端已经结束了自己这边数据的传输，但是仍旧可以接收服务器端发来的东西，上图中双方判断对方已经关闭了连接的方法是看read系统调用是否返回0</p><h4 id="连接超时"><a href="#连接超时" class="headerlink" title="连接超时"></a>连接超时</h4><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220624225400.png" alt="连接超时"><br>每次超时，超时时间加倍，由内核变量tcp_syn_retries决定，5次连接都失败的情况下，TCP模块放弃连接通知应用程序</p><h3 id="3-4-TCP状态转移"><a href="#3-4-TCP状态转移" class="headerlink" title="3.4 TCP状态转移"></a>3.4 TCP状态转移</h3>]]></content>
      
      
      <categories>
          
          <category> Linux高性能服务器阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0623题目</title>
      <link href="/2022/06/23/acw%E9%A2%98%E7%9B%AE/0623%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/06/23/acw%E9%A2%98%E7%9B%AE/0623%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="峰会"><a href="#峰会" class="headerlink" title="峰会"></a>峰会</h2><p>由于数据范围比较小，所以可以直接暴力求解，时间复杂度是 $O(N^3)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">bool</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m); <span class="comment">// 读入首脑数量、边的数量</span></span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        g[a][b] = g[b][a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m); <span class="comment">// 读入询问的数量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123; <span class="comment">// 这是第几次询问</span></span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="type">int</span> cnt;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt); <span class="comment">// 这一组有多少首脑</span></span><br><span class="line">        <span class="comment">// 读入这组的所有首脑</span></span><br><span class="line">        <span class="keyword">while</span>(cnt--)&#123;</span><br><span class="line">            <span class="type">int</span> temp;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">            st[temp] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始判断要输出什么</span></span><br><span class="line">        <span class="type">bool</span> flag1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                <span class="comment">// i和j都在这组里 但是他们之间没有边</span></span><br><span class="line">                <span class="keyword">if</span>(st[i] &amp;&amp; st[j] &amp;&amp; !g[i][j])&#123;</span><br><span class="line">                    flag1 = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag1) <span class="built_in">printf</span>(<span class="string">&quot;Area %d needs help.\n&quot;</span>, i);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 如果满足 看看能否有新的可以加入</span></span><br><span class="line">            <span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">                <span class="comment">// k不在现在的里面</span></span><br><span class="line">                <span class="type">bool</span> flag2 = <span class="literal">true</span>; <span class="comment">// 每一轮的判断 flag2重置为true</span></span><br><span class="line">                <span class="keyword">if</span>(!st[k])&#123;</span><br><span class="line">                    <span class="comment">// cout &lt;&lt; &quot;k:&quot; &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>; p &lt;= n; p++)&#123;</span><br><span class="line">                        <span class="comment">// cout &lt;&lt; &quot;p:&quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; st[p] &lt;&lt; &quot; &quot; &lt;&lt; !g[p][k] &lt;&lt; endl;</span></span><br><span class="line">                        <span class="keyword">if</span>(st[p] &amp;&amp; !g[p][k])&#123;</span><br><span class="line">                            flag2 = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(flag2)&#123;</span><br><span class="line">                        tt = k;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tt)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Area %d may invite more people, such as %d.\n&quot;</span>, i, tt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Area %d is OK.\n&quot;</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-06-23</title>
      <link href="/2022/06/23/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-23/"/>
      <url>/2022/06/23/%E9%98%85%E8%AF%BB%E4%B9%A6%E7%9B%AE/linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/22-06-23/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-tcp-x2F-ip协议族体系结构"><a href="#1-1-tcp-x2F-ip协议族体系结构" class="headerlink" title="1.1 tcp&#x2F;ip协议族体系结构"></a>1.1 tcp&#x2F;ip协议族体系结构</h2><h3 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h3><p>整个体系结构就是下层为上层提供服务，要想使用数据链路层的功能就要有数据链路层里用的MAC地址，MAC地址可以通过ARP协议通过IP地址得到,<br>另外还有RARP协议,RARP就是反过来，通过MAC地址获得IP地址，主要用于无盘的机器，就是不能存储自己的IP地址，但是可以通过自己的MAC来查询</p><h3 id="1-1-2-网络层"><a href="#1-1-2-网络层" class="headerlink" title="1.1.2 网络层"></a>1.1.2 网络层</h3><p>网络层最经典的就是IP协议，IP协议其实就是封装了网络的拓扑结构，传输层上仿佛两个机器的直接通信，其实是网络层通过路由选择，一跳一跳的选择下一跳地址，<br>来将两个主机连接起来，<br>还有ICMP协议，ICMP协议借用了IP协议的服务<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220623210040.png" alt="ICMP报文字段"></p><h3 id="1-1-3-传输层"><a href="#1-1-3-传输层" class="headerlink" title="1.1.3 传输层"></a>1.1.3 传输层</h3><p>传输层经典的TCP协议(传输控制协议)，TCP协议是可靠的，基于字节流传输的，发送端可以逐个向数据流里写入，接收端可以逐个读出；<br>UDP(用户数据报协议)是不可靠的，基于数据报，每个数据报都有一个长度，接收端只能以该长度读出；<br>SCTP协议(流控制传输协议)： 在因特网传输电话信号</p><h3 id="1-1-4-应用层"><a href="#1-1-4-应用层" class="headerlink" title="1.1.4 应用层"></a>1.1.4 应用层</h3><p>应用层在用户空间实现，传输层以下都是在内核空间实现，如果也在内核，可以省去来回切换的麻烦，但是导致内核庞大、实现复杂，<br>比如</p><ul><li>ping</li><li>telnet 远程登陆协议</li><li>DNS</li><li>OSPF 开放最短路径优先 动态路由更新协议</li></ul><p>可以在&#x2F;etc&#x2F;services里查看</p><h2 id="1-2-封装"><a href="#1-2-封装" class="headerlink" title="1.2 封装"></a>1.2 封装</h2><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220623211424.png" alt="封装过程图"></p><p>当发送端应用程序使用send(write)向一个TCP连接写入数据时，内核中的TCP模块会将这些数据复制到与该连接对应的TCP内核发送缓冲区，然后TCP模块<br>调用IP模块提供的服务，传递的参数包括TCP头部信息和TCP发送缓冲区中的数据<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220623211654.png" alt="TCP封装过程"></p><p>经过UDP封装后的数据称为UDP数据报，UDP无须为应用层数据保存副本，因为它提供的服务是不可靠的。<br>当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。<br>如果应用程序检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区中。<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220623212107.png" alt="帧结构"></p><h2 id="1-3-分用"><a href="#1-3-分用" class="headerlink" title="1.3 分用"></a>1.3 分用</h2><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220623214321.png" alt="分用"><br>因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的头部需要提供某个<br>字段（具体情况取决于帧的类型）来区分它们。以以太网帧为例，它使用2字节的类型字段<br>来标识上层协议（见图1-6）。如果主机接收到的以太网帧类型字段的值为0x800,则帧的数<br>据部分为P数据报（见图1-4），以太网驱动程序就将帧交付给IP模块：若类型字段的值为<br>0x806,则帧的数据部分为ARP请求或应答报文，以太网驱动程序就将帧交付给ARP模块：<br>若类型字段的值为0x835,则帧的数据部分为RARP请求或应答报文，以太网驱动程序就将<br>帧交付给RARP模块。</p><h2 id="1-5-arp协议工作原理"><a href="#1-5-arp协议工作原理" class="headerlink" title="1.5 arp协议工作原理"></a>1.5 arp协议工作原理</h2><p>工作原理：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器的网络地址。此网络上的其它机器接收这个请求后，目标机器会响应一个APR应答，<br>包含自己的MAC地址</p><p>arp高速缓存: 存储常用的和最近使用的一些MAC和IP的关系<br>arp -a可以查询</p><h2 id="1-6-DNS工作原理"><a href="#1-6-DNS工作原理" class="headerlink" title="1.6 DNS工作原理"></a>1.6 DNS工作原理</h2><p>linux下可以利用host指令 利用dns协议和dns服务器进行通讯<br>比如:<br>host -t A <a href="http://www.baidu.com/">www.baidu.com</a> (-t表示选择哪种查询类型 A表示域名和IP的对应)<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220623231514.png" alt="host指令"></p><h2 id="1-7-socket与TCP-x2F-IP协议族的关系"><a href="#1-7-socket与TCP-x2F-IP协议族的关系" class="headerlink" title="1.7 socket与TCP&#x2F;IP协议族的关系"></a>1.7 socket与TCP&#x2F;IP协议族的关系</h2><p>数据链路层、网络层、传输层都是在内核实现的，操作系统就需要提供系统调用来使得应用程序可以使用这些协议提供的服务，<br>实现这组系统调用的API主要是socket</p><p>socket主要的功能在于:</p><ul><li>将应用程序数据从用户缓冲区复制到TCP&#x2F;UDP内核发送缓冲区，用来交付内核来发送数据；将TCP&#x2F;UDP接收缓冲区中的数据复制到用户缓冲区来读取数据</li><li>应用程序通过他们可以修改这些底层协议的某些头部信息或其它数据结构，来精细的控制底层通信的行为</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux高性能服务器阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0620题目</title>
      <link href="/2022/06/20/acw%E9%A2%98%E7%9B%AE/0620%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/06/20/acw%E9%A2%98%E7%9B%AE/0620%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="格斗场"><a href="#格斗场" class="headerlink" title="格斗场"></a>格斗场</h2><p>双指针算法<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/origin_img_v2_df36981b-d7a8-45b6-9311-02df2297650g.jpg" alt="题目分析"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">sort</span>(a, a + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> res = n;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; n; i++)&#123; <span class="comment">// 注意如果要在这里加入j的判断 需要 j &lt;= n</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; a[j] - a[i] &lt;= k) j++;</span><br><span class="line">        <span class="keyword">if</span>(a[j<span class="number">-1</span>] &gt; a[i]) res--; <span class="comment">// 至少要有一个满足大于 否则不能保证成立</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="有限小数"><a href="#有限小数" class="headerlink" title="有限小数"></a>有限小数</h2><p>小数的进制转化 gcd最大公约数的应用<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/origin_img_v2_a32750d5-888a-4463-ba52-443e4417fa3g.jpg" alt="题目分析"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a, LL b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b, a % b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        LL p, q, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld%lld&quot;</span>, &amp;p, &amp;q, &amp;b);</span><br><span class="line">        LL d = <span class="built_in">gcd</span>(p, q);</span><br><span class="line">        q /= d;</span><br><span class="line">        <span class="keyword">while</span>(q &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            d = <span class="built_in">gcd</span>(q, b);</span><br><span class="line">            <span class="keyword">if</span>(d == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span>(q % d == <span class="number">0</span>) q /= d; <span class="comment">// 每次除d除干净</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好多天没更新博客了，刷完题赶紧过来更新一下，不然感觉以后会越来越鸽</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Primer -- 1</title>
      <link href="/2022/06/01/C++%20Primer%E5%AD%A6%E4%B9%A0/1/"/>
      <url>/2022/06/01/C++%20Primer%E5%AD%A6%E4%B9%A0/1/</url>
      
        <content type="html"><![CDATA[<h3 id="数组尾后指针"><a href="#数组尾后指针" class="headerlink" title="数组尾后指针"></a>数组尾后指针</h3><p>比如数组A的元素个数有n个，那么可以通过 &amp;A[n] 来获得尾元素指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span>* first = a;</span><br><span class="line"><span class="type">int</span>* last = &amp;a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* c = first; c != last; c++) &#123;</span><br><span class="line">cout &lt;&lt; *c &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有更加简单的方法, 通过begin和end函数来获取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">12</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span>* beg = <span class="built_in">begin</span>(a);</span><br><span class="line"><span class="type">int</span>* last = <span class="built_in">end</span>(a);</span><br><span class="line"><span class="keyword">for</span> (; beg != last; beg++) &#123;</span><br><span class="line">cout &lt;&lt; *beg &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出是 0 1 2 3 4 5 6 7 8 9 0 0</span></span><br><span class="line"><span class="comment">// 说明是输出 数组所有空间这么大的内容</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标准库类型下标和内置下标区别"><a href="#标准库类型下标和内置下标区别" class="headerlink" title="标准库类型下标和内置下标区别"></a>标准库类型下标和内置下标区别</h3><p>标准库类型string和vector也能执行下标运算，但是数组与他们相比还是有所不同，标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求，内置的下标运算可以处理负数的值，当然，结果地址必须指向原来的指针所指同一数组中的元素(或者是同一数组尾元素的下一位置)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ia[] = &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span> &#125;;</span><br><span class="line"><span class="type">int</span>* p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> j = p[<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> k = p[<span class="number">-2</span>];</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;j: &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; k: &quot;</span> &lt;&lt; k &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出 6 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="P108-练习3-34"><a href="#P108-练习3-34" class="headerlink" title="P108 练习3.34"></a>P108 练习3.34</h3><p>什么情况下 p1 +&#x3D; p2 - p1是非法的 (p1 p2是指向数组中的元素)</p><p>p1, p2不在同一数组内的时候，这个是非法的，不在同一数组里不能这么减</p><h3 id="P110-练习3-37"><a href="#P110-练习3-37" class="headerlink" title="P110 练习3.37"></a>P110 练习3.37</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> ca[] = &#123; <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cp = ca;</span><br><span class="line"><span class="keyword">while</span> (*cp) &#123;</span><br><span class="line">cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">cp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种列表初始化的方式是没有\0的，因此程序会超出数组的范围一直输出知道遇到\0</p><h3 id="c-str"><a href="#c-str" class="headerlink" title="c_str()"></a>c_str()</h3><p>c_str()函数的使用非常有意思 主要是用于将string对象转化为C类型的字符串，也就是字符数组，c_str()会返回带\0的字符数组<br>而且返回的是 const char*类型的指针，因此我们无法修改里面的字符</p><p>蛋疼的是，如果你改变了原来string对象的值，连你这个字符数组也会响应的改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* str = s.<span class="built_in">c_str</span>();</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = str;</span><br><span class="line"><span class="keyword">while</span> (*p) &#123;</span><br><span class="line">cout &lt;&lt; *p;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello world</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">s.<span class="built_in">append</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ss = str;</span><br><span class="line"><span class="keyword">while</span> (*ss) &#123;</span><br><span class="line">cout &lt;&lt; *ss;</span><br><span class="line">ss++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello world123</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，从使用的角度来看，我们只是想要获得这个对象的值，如果我们后续要对它进行操作，我们需要将它拷贝到另外的字符数组里去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* cstr, *p;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">&quot;Please split this phrase into tokens&quot;</span>)</span></span>;</span><br><span class="line">cstr = <span class="keyword">new</span> <span class="type">char</span>[str.<span class="built_in">size</span>() + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(cstr, str.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure><h3 id="多维数组的范围for语句"><a href="#多维数组的范围for语句" class="headerlink" title="多维数组的范围for语句"></a>多维数组的范围for语句</h3><p>如何用范围for语句来遍历一个多维数组呢?<br>比如说现在有个数组 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">4</span>&#125; &#125;;</span><br></pre></td></tr></table></figure><p>啥也不想可能会:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x : a) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; y : x) &#123;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传引用，代表我们可能需要修改里面的值</p><p>那么如果我们不想修改，不传引用，直接写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> x : a) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> y : x) &#123;</span><br><span class="line">cout &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 x 的位置会报错，书上解释说 x此时其实是一个指针类型，我们不能对执行类型进行范围遍历的操作<br>之前可以是因为加了引用，x就是代表一个长度为2的数组</p><p>因此我们可以总结：<br>如果要使用范围for语句来处理多维数组，除了最内层的循环，其它都要使用引用，最内层循环用引用还是不用，取决于你是否要对原数组进行修改</p>]]></content>
      
      
      <categories>
          
          <category> C++ Primer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ Primer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第294场周赛</title>
      <link href="/2022/05/28/leetcode%E5%91%A8%E8%B5%9B/leetcode%E7%AC%AC294%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/05/28/leetcode%E5%91%A8%E8%B5%9B/leetcode%E7%AC%AC294%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="lc2280-表示一个折线图的最少线段数"><a href="#lc2280-表示一个折线图的最少线段数" class="headerlink" title="lc2280. 表示一个折线图的最少线段数"></a><a href="https://leetcode.cn/problems/minimum-lines-to-represent-a-line-chart/">lc2280. 表示一个折线图的最少线段数</a></h2><p>比如说三个点形成的折线图，如果三点一线就只需要一条线，如果不在一条线就需要两条，也就是 n - 1<br>那么这题目就是在问你有哪些三个点是三点一线的<br>因此只需要从第一个点开始遍历，每次找三个点看看是不是一条线，如果是，结果值-1，<b>注意这里的步长为1</b><br>至于判断三个点 $(x1, y1)$ $(x2, y2)$ $(x3, y3)$是不是三点一线只需要<br>$(x1 - x2)\ast(y1 - y3) &#x3D; (x1 - x3)\ast(y1 - y2)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minimumLines</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), res = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> dx12 = s[i][<span class="number">0</span>] - s[i+<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> dx13 = s[i][<span class="number">0</span>] - s[i+<span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> dy12 = s[i][<span class="number">1</span>] - s[i+<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> dy13 = s[i][<span class="number">1</span>] - s[i+<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)dx12 * dy13 == (<span class="type">long</span> <span class="type">long</span>)dx13 * dy12)&#123;</span><br><span class="line">                res--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc2281-巫师的总力量和"><a href="#lc2281-巫师的总力量和" class="headerlink" title="lc2281. 巫师的总力量和"></a><a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/">lc2281. 巫师的总力量和</a></h2><p>这题太刁了—<br>本质上就是求所有子数组的加权和(这里的权指的是这个子数组里的最小值)</p><p>如果没有加权，只是单纯求所有子数组的和怎么求?<br>显然可以先通过 $O(N)$ 算出前缀和，前缀和可以帮我们在 $O(1)$ 时间内算出任意子数组的和<br>但是为了求所有子数组，我们需要遍历左右两个端点，也就是 $O(N^2)$ 的时间，整体的复杂度就是 $O(N^2)$</p><p>有没有更快的方法?<br>比如我们要求 ${1, 2, 3, 4, 5}$ 的子数组和<br>我们可以把子数组分成 以1结尾，以2结尾… 这样的部分，下图的三角形每行就是以3结尾的子数组<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220528090533.png" alt="子数组和"><br>所以可以直接按照每列出现的次数和每列的和直接乘起来就有了结果</p><p>那么回到这题，<br>所有子数组的加权和 &#x3D; 以第一个数为最小值的子数组和 * 第一个数 + 以第二个数为最小值的子数组和 * 第二个数 + … + 以最后一个数为最小值的子数组和 * 最后一个数</p><p>那么首先我们就需要知道以每个数为最小值的子数组范围是多少，对于 a[i] 它最小的子数组范围是啥?<br>求a[i]左边第一个比它小的数出现的位置 右边也是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// sl 记录左边第一个比i小的出现的地方</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">1</span> &amp;&amp; a[j] &gt;= a[i]; j = s1[j]);</span><br><span class="line">    s1[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// s2 记录右边第一个比i小出现的地方</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">    <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; j &lt;= n &amp;&amp; a[j] &gt; a[i]; j = s2[j]);</span><br><span class="line">    s2[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220528091521.png"><br>以1为最小的子数组的范围求出来了，那么接下来就是怎么求的问题?<br>我们可以分成左右两个部分，<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220528094356.png"><br>左边以1为结尾且以1为最小值的所有子数组，一共有3个<br>右边从1开始(不算1)的所有子数组，一共有3个<br>所有包含1的子数组本质上就是左边选一个右边选一个(右边可以不选)然后两边搭配起来<br>所有子数组的和 &#x3D; 左边三角形的面积 * (右边行数 + 1) + 右边三角形的面积 * 左边的行数<br>左边三角形面积的求法:<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220528095431.png"><br>右边三角形面积的求法:<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220528095943.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> s1[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> s2[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ss1[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ss2[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre_sum[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalStrength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; strength)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 迁移一手</span></span><br><span class="line">        <span class="type">int</span> n = strength.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i + <span class="number">1</span>] = strength[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sl 记录左边第一个比i小的出现的地方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">1</span> &amp;&amp; a[j] &gt;= a[i]; j = s1[j]);</span><br><span class="line">            s1[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s2 记录右边第一个比i小出现的地方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &lt;= n &amp;&amp; a[j] &gt; a[i]; j = s2[j]);</span><br><span class="line">            s2[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边来一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ss1[i] = ss1[i - <span class="number">1</span>] + (<span class="type">long</span> <span class="type">long</span>)a[i] * i % p;</span><br><span class="line">            ss1[i] %= p;</span><br><span class="line">            pre_sum[i] = pre_sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">            pre_sum[i] %= p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右边来一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            ss2[i] = ss2[i + <span class="number">1</span>] + (<span class="type">long</span> <span class="type">long</span>)(n + <span class="number">1</span> - i) * a[i] % p;</span><br><span class="line">            ss2[i] %= p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后就可以开始算了</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = s1[i] + <span class="number">1</span>, r = s2[i] - <span class="number">1</span>;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> x = ((ss1[i] - ss1[l - <span class="number">1</span>] + p) % p - (pre_sum[i] - pre_sum[l - <span class="number">1</span>] + p) % p * (l - <span class="number">1</span>) % p + p) % p;</span><br><span class="line">            res += x * (r - i + <span class="number">1</span>) % p * a[i] % p;</span><br><span class="line">            res %= p;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> y = ((ss2[i + <span class="number">1</span>] - ss2[r + <span class="number">1</span>] + p) % p - (pre_sum[r] - pre_sum[i]) % p * (n - r) % p + p) % p;</span><br><span class="line">            res += y * (i - l + <span class="number">1</span>) % p * a[i] % p;</span><br><span class="line">            res %= p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里引入lc的另外一道题:<br><a href="https://leetcode.cn/problems/sum-of-subarray-minimums/">907. 子数组的最小值之和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> sl[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">int</span> sr[<span class="number">100010</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> p = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumSubarrayMins</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            a[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &gt;= <span class="number">1</span> &amp;&amp; a[j] &gt;= a[i]; j = sl[j]);</span><br><span class="line">            sl[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(; j &lt;= n &amp;&amp; a[j] &gt; a[i]; j = sr[j]);</span><br><span class="line">            sr[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> temp = (<span class="type">long</span> <span class="type">long</span>)(sr[i] - i)*(i - sl[i])%p*a[i]%p;</span><br><span class="line">            res = (res + temp)%p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二问的题解参考自:<br><a href="https://mp.weixin.qq.com/s?__biz=MzI2NzQ3OTQ1Mw==&mid=2247485030&idx=1&sn=b648c8a3c8a9b8fce625765fb345d233&chksm=eaff7694dd88ff825dd71a9b740dcba6711f192220c718361382b70534718b0d98936b5514c4&token=1764672036&lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz&#x3D;MzI2NzQ3OTQ1Mw&#x3D;&#x3D;&amp;mid&#x3D;2247485030&amp;idx&#x3D;1&amp;sn&#x3D;b648c8a3c8a9b8fce625765fb345d233&amp;chksm&#x3D;eaff7694dd88ff825dd71a9b740dcba6711f192220c718361382b70534718b0d98936b5514c4&amp;token&#x3D;1764672036&amp;lang&#x3D;zh_CN#rd</a></p>]]></content>
      
      
      <categories>
          
          <category> leetcode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lc周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVTE笔试</title>
      <link href="/2022/05/25/2022%E6%9A%91%E6%9C%9F%E7%AC%94%E8%AF%95/CVTE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AF%95/"/>
      <url>/2022/05/25/2022%E6%9A%91%E6%9C%9F%E7%AC%94%E8%AF%95/CVTE%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><p>DRAM: 动态随机存取存储器(Dynamic Random Access Memory，DRAM)<br>也叫主存，是与CPU直接交换数据的内部存储器</p><p>SRAM: 静态随机存取存储器（Static Random-Access Memory，SRAM）<br>这种存储器只要保持通电，里面储存的数据就可以恒常保持</p><p>flash: 存储芯片之一<br>flash是存储芯片的一种，通过特定的程序可以修改里面的数据。FLASH在电子以及半导体领域内往往表示Flash Memory的意思，即平时所说的“闪存”，全名叫Flash EEPROM Memory。<br>flash存储器又称闪存，它结合了ROM和RAM的长处，不仅具备电子可擦除可编程（EEPROM）的性能，还可以快速读取数据（NVRAM的优势），使数据不会因为断电而丢失。</p><p>U盘和MP3里用的就是这种存储器。在过去的20年里，嵌入式系统一直使用ROM（EPROM）作为它们的存储设备，然而近年来Flash全面代替了ROM（EPROM）在嵌入式系统中的地位，用作存储Bootloader以及操作系统或者程序代码，或者直接当硬盘使用（U盘）</p><p>EEPROM: Electrically Erasable Programmable read only memory<br>带电可擦可编程只读存储器。是一种掉电后数据不丢失的存储芯片。 EEPROM 可以在电脑上或专用设备上擦除已有信息，重新编程。一般用在即插即用。</p><h3 id="设置内核打印等级"><a href="#设置内核打印等级" class="headerlink" title="设置内核打印等级"></a>设置内核打印等级</h3><p>修改&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk文件内容控制打印信息：默认设置是7  4  1  7<br>该文件有四个数字值，它们根据日志记录消息的重要性，定义将其发送到何处。关于不同日志级别的更多信息，请查阅syslog(2)联机帮助。</p><ul><li><p>控制台日志级别：优先级高于该值的消息将被打印至控制台</p></li><li><p>默认的消息日志级别：将用该优先级来打印没有优先级的消息</p></li><li><p>最低的控制台日志级别：控制台日志级别可被设置的最小值(最高优先级)</p></li><li><p>默认的控制台日志级别：控制台日志级别的缺省值</p></li></ul><p>数值越小，优先级越高<br>其实这四个值是在kernel&#x2F;printk.c 中被定义的，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    DEFAULT_CONSOLE_LOGLEVEL,       <span class="comment">/* console_loglevel */</span></span><br><span class="line"></span><br><span class="line">    DEFAULT_MESSAGE_LOGLEVEL,       <span class="comment">/* default_message_loglevel */</span></span><br><span class="line"></span><br><span class="line">    MINIMUM_CONSOLE_LOGLEVEL,     <span class="comment">/* minimum_console_loglevel */</span></span><br><span class="line"></span><br><span class="line">    DEFAULT_CONSOLE_LOGLEVEL,       <span class="comment">/* default_console_loglevel */</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核通过printk() 输出的信息具有日志级别，日志级别是通过在printk() 输出的字符串前加一个带尖括号的整数来控制的，<br>如printk(“&lt;6&gt;Hello, world!\n”);。内核中共提供了八种不同的日志级别，在 linux&#x2F;kernel.h 中有相应的宏对应。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG  <span class="string">&quot;&lt;0&gt;&quot;</span>   <span class="comment">/* systemis unusable */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ALERT  <span class="string">&quot;&lt;1&gt;&quot;</span>   <span class="comment">/* actionmust be taken immediately */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_CRIT    <span class="string">&quot;&lt;2&gt;&quot;</span>   <span class="comment">/*critical conditions */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ERR     <span class="string">&quot;&lt;3&gt;&quot;</span>   <span class="comment">/* errorconditions */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_WARNING <span class="string">&quot;&lt;4&gt;&quot;</span>   <span class="comment">/* warning conditions */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_NOTICE  <span class="string">&quot;&lt;5&gt;&quot;</span>   <span class="comment">/* normalbut significant */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_INFO    <span class="string">&quot;&lt;6&gt;&quot;</span>   <span class="comment">/*informational */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DEBUG   <span class="string">&quot;&lt;7&gt;&quot;</span>   <span class="comment">/*debug-level messages */</span></span></span><br></pre></td></tr></table></figure><p>所以printk() 可以这样用：printk(KERN_INFO”Hello, world!\n”)<br>未指定日志级别的printk() 采用的默认级别是DEFAULT_MESSAGE_LOGLEVEL，这个宏在kernel&#x2F;printk.c 中被定义为整数4，即对应KERN_WARNING。</p><p>如果要想在内核启动过程中打印少的信息，就可以根据自己的需要在kernel&#x2F;printk.c中修改以上数值，重新编译即可！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* printk&#x27;s without a loglevel use this.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MESSAGE_LOGLEVEL 4 <span class="comment">/* KERN_WARNING */</span></span></span><br></pre></td></tr></table></figure><p>了解了上面的这些知识后，我们就应该知道如何手动控制printk打印了。例如，我想屏蔽掉所有的内核printk打印，那么我只需要把第一个数值调到最小值1或者0。</p><p>echo 1  4  1  7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk<br>echo 0  4  0  7 &gt; &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;printk</p><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><p>顺序表指的是数组，单链表就是链表(有被自己蠢到)</p><h3 id="冒泡排序比较次数"><a href="#冒泡排序比较次数" class="headerlink" title="冒泡排序比较次数"></a>冒泡排序比较次数</h3><p>$O(\frac{N(N-1)}{2})$</p><h3 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h3><p>不了解</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>ps -a好像是所有进程<br>ps -u貌似是和用户有关</p><h3 id="vim删除当前行"><a href="#vim删除当前行" class="headerlink" title="vim删除当前行"></a>vim删除当前行</h3><p>dd 删除光标所在行</p><ul><li>删除多行 如果要删除第4行以下的3行，请按下 3 dd</li><li>删除给定范围的行 :3,5d</li><li>删除最后一行 :$d</li><li>删除当前行之前的所有行 :1,.-1d</li><li>删除当前行之后的所有行 :.+1,$d</li></ul><h3 id="linux驱动层"><a href="#linux驱动层" class="headerlink" title="linux驱动层"></a>linux驱动层</h3><p>字符设备驱动就是指以字符流为数据通信基础的设备。 例如：LCD、键盘、I2C等。</p><h3 id="arm微处理器"><a href="#arm微处理器" class="headerlink" title="arm微处理器"></a>arm微处理器</h3><p>大端格式和小端格式</p><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p>硬链接的特点:</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li>删除一个硬链接文件并不影响其他有相同 inode 号的文件。</li></ul><p>软链接的特点:</p><ul><li>软链接有自己的文件属性及权限等；</li><li>可对不存在的文件或目录创建软链接，当链接到的文件存在时，即可直接通过软链接访问</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即dangling link，若被指向路径文件被重新创建，<br>死链接可恢复为正常的软链接）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暑期实习 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-22</title>
      <link href="/2022/05/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-22/"/>
      <url>/2022/05/22/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-22/</url>
      
        <content type="html"><![CDATA[<h2 id="最近"><a href="#最近" class="headerlink" title="最近"></a>最近</h2><p>昨天终于考完了编译原理和数据库，哎，感觉数据库肯定是过了，但是编译原理好像要挂了）</p><p>编译原理感觉这门课我自己都还没入门</p><p>为啥还是没有实习 —- 寄</p><p>看到个最近距离的题目 准备收录一波</p>]]></content>
      
      
      <categories>
          
          <category> 每日一水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>招商银行笔试</title>
      <link href="/2022/05/13/2022%E6%9A%91%E6%9C%9F%E7%AC%94%E8%AF%95/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C%E7%AC%94%E8%AF%95/"/>
      <url>/2022/05/13/2022%E6%9A%91%E6%9C%9F%E7%AC%94%E8%AF%95/%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220513220918.png" alt="树的节点"></p><h3 id="rm指令"><a href="#rm指令" class="headerlink" title="rm指令"></a>rm指令</h3><ul><li>rm -i 删除前逐一询问确认</li><li>rm -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认</li><li>rm -r 将目录及以下之档案亦逐一删除<br>(好像没有题目中的 rm -d选项)</li></ul><h3 id="数据库的隔离性"><a href="#数据库的隔离性" class="headerlink" title="数据库的隔离性"></a>数据库的隔离性</h3><p>并发访问数据库时，一个用户的事务不被其它事务所干扰，各并发事务之间数据库是独立的<br>（原子性和持久性都是基于单个事务内部的措施，而隔离性是多个事务之间相互隔离、互不影响的特性）</p><p>事务的四个隔离级别：</p><ol><li>READ-UNCOMMITTED(读未提交)<br> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li><li>READ-COMMITTED(读已提交)<br> 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读和不可重复读仍有可能发生</li><li>REPEATABLE-READ(可重复读)<br> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但是幻读仍有可能发生</li><li>SERIALIZABLE(可串行化)<br> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，该级别可以防止脏读、不可重复读以及幻读。</li></ol><p>Mysql 默认采用的 <b>可重复读隔离级别</b> ，Oracle 默认采用的<b>读已提交隔离级别</b><br>InnoDB 存储引擎在 分布式事务 的情况下一般会用到可串行化隔离级别。</p><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><p><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220513230019.png" alt="L0、L1、L2范数"></p><h3 id="xss类型"><a href="#xss类型" class="headerlink" title="xss类型"></a>xss类型</h3><ul><li>反射型XSS</li><li>DOM-based型XXS</li><li>存储型XSS（持久型XSS）</li></ul><p>反射型 XSS 一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。反射型XSS通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p><p>久型XSS，主要将XSS代码提交存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交XSS代码。当目标用户访问该页面获取数据时，XSS代码会从服务器解析之后加载出来，返回到浏览器做正常的HTML和JS解析执行，XSS攻击就发生了。存储型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。</p>]]></content>
      
      
      <categories>
          
          <category> 笔试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暑期实习 笔试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-13</title>
      <link href="/2022/05/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-13/"/>
      <url>/2022/05/13/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-13/</url>
      
        <content type="html"><![CDATA[<h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>今天起得巨早，8点就醒了，起来随便塞了点东西吃吃就去看编译原理了，这课简直绝了，真的感觉要挂科），看到语法制导翻译了，<br>感觉要来不及看了）— 唉</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>下午 emmmm 看了会甘辉城乐园，京阿尼的画风还是很好看的呀，然后就到了亲爱的源老师课堂，哈哈，写个板书他竟然卡壳了，笑死我了，<br>建议下次还是老老实实念PPT吧，啊这，原来课结束了，没有下次了，好哎！！！！！</p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>翘掉了实验课去打了会儿球，平板和充电器都先放回宿舍了，只能在自习室歇会儿，补补之前没写的博客了）</p>]]></content>
      
      
      <categories>
          
          <category> 每日一水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-12</title>
      <link href="/2022/05/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-12/"/>
      <url>/2022/05/12/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-12/</url>
      
        <content type="html"><![CDATA[<p>昨天没写 今天13号补上）</p>]]></content>
      
      
      <categories>
          
          <category> 每日一水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4399和招商银行</title>
      <link href="/2022/05/11/2022%E6%9A%91%E6%9C%9F%E9%9D%A2%E8%AF%95/4399%E5%92%8C%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/"/>
      <url>/2022/05/11/2022%E6%9A%91%E6%9C%9F%E9%9D%A2%E8%AF%95/4399%E5%92%8C%E6%8B%9B%E5%95%86%E9%93%B6%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="4399面试"><a href="#4399面试" class="headerlink" title="4399面试"></a>4399面试</h2><p>介绍一下你自己–</p><p>介绍一下自己的项目</p><p>又又又选择了说自己的CSAPP实验　这门课真是学的绝了</p><p>大小端判断、浮点数的存储— 没反应</p><p>动态内存分配器 问了问分配内存时候 最佳匹配和第一次匹配（还是啥）的优点和缺点<br>大概说了说最佳匹配性能弱点，第一次匹配可能会导致内存碎片之类的</p><p>提到 拆炸弹的Lab 提到一嘴反汇编 问了问ELF格式的文件结构<br>说了说 文件头、data段、text段、rodata段、bss段、注释段、堆栈信息段之类的<br>问了问常量字符串在哪个段？(rodata) 未初始化的全局变量或者静态变量在哪里（data、bss段之类的）</p><p>问了问http代理服务器那个项目<br>说了句一个进程在跑，如果遇到一个请求，就直接开个线程去处理（精准踩雷）</p><p>问了问 线程A打开一个文件，线程B可以再打开吗（当然可以）<br>如果已知地址，线程A可以访问B的栈吗？（可以的吧　不确定）<br>线程的空间资源主要用在哪里？（线程id、栈、程序计数器之类的）</p><p>然后问我是否知道IO多路复用之类的？<br>回答了select的东西（不敢回答 epoll poll 怕直接被问爆）</p><p>面试内容大概就问了这么多》》 感觉效果还可以 不知道能不能过？</p><p>然后就是问了问为啥投游戏公司、问啥不考研、平时的学习方法啥的——</p><p>反问：面试官主要做的啥方面</p><h2 id="招商银行"><a href="#招商银行" class="headerlink" title="招商银行"></a>招商银行</h2><p>直接一个大写的寄</p><p>为啥我投的服务器开发，问的都是些Java的东西 人直接麻了</p><p>不过问的倒是挺简单的，可惜完全没准备过</p><p>自我介绍提到Java 直接开始问爆</p><p>让我介绍下自己写的Java项目 说了商品管理系统）我直接人麻了</p><p>问我遇到了什么问题）我一个小小前后端能有啥问题<br>只能胡扯说遇到了同步异步的问题，好家伙直接问我怎么解决的，支支吾吾说在前端定义了两个函数的前后关系，<br>让它从异步转同步，然后又继续追问怎么转的？？ 我直接好家伙 只能说用什么async 还是 sync什么关键字（不了解）搞的<br>对面竟然点了点头 貌似他也用过？</p><p>然后得知了我用过spring boot 直接问我Controller层用了什么注解？ 寄啦 我咋记得代码嘛—</p><p>当场尴尬– 感觉这个面试官被我搞懵了（ps:有两个面试官）</p><p>然后问我熟不熟悉linux 我直接好家伙 直呼知道常用指令</p><p>问我查看CPU使用情况用啥情况？ 好家伙完全不会 只记得好像top可以 顺嘴提了 ps aux<br>结果直接问我ps aux输出啥 回答忘了（艹 不该胡乱说话）</p><p>网上搜了搜 貌似可能是想让我回答 vmstat<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220511194618.png" alt="linux查看CPU使用"></p><p>后来提到我的项目是跑在本地还是哪儿？</p><p>想起以前大一搞过部署到云服务器，结果问我jar包怎么打包出来的？</p><p>我直呼 idea直接点出来的 又问我哪里点的？ 我怎么可能记得 ） 大寄</p><p>然后问我jar包怎么传到服务器 有没有种可能想让我回答 scp指令 结果我回答直接拖拽 艹 乐死我了</p><p>直接xftp传</p><p>这把可真是尴尬爆表，这个面试官可能意识到了我有多垃圾，所以选择了沉默，另一个面试官上了）</p><p>问了手：“你说你熟悉计算机网络，谈谈序列号的作用”</p><p>好家伙，我直呼序列号可以帮你确认分组，确认ack发什么？ 他好像说我说了大半） 并不了解还让我说啥<br>序列号难道不就是数据包最初始数据的那个号码嘛）</p><p>中途倒是谈到了ICMP协议，稍微吹了会儿水 感觉发挥可以</p><p>感觉这把招商银行是面的凉了，本来还想去的呢） </p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暑期实习 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-11</title>
      <link href="/2022/05/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-11/"/>
      <url>/2022/05/11/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-11/</url>
      
        <content type="html"><![CDATA[<h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>8:30左右醒来，昨晚三点多才睡（热爆了），半夜下床找风扇结果还没找着，又灰溜溜的回床睡了，貌似是时间已经够晚了，<br>后来也成功入睡了</p><p>可怕）想起了去年暑假的悲惨时光</p><p>早上看了会儿？emmmm 好家伙 好像早上没看啥 看了会儿C++的东西 然后睡了会儿 实在太困了</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>和架构师请了个假，毕竟下午有4399的面试</p><p>感觉4399的面试 emmmm 发挥还算可以的样子 应该不会被挂吧） 唉</p><p>面完了4：20左右，结果接到电话？ 招商银行的电话？？？ —- 发现自己记错面试时间了</p><p>5：30 粗略的面完了招商银行 唉） 感觉特定挂了 问了好多Java的东西 我直接人麻了</p><p>问了不少 springboot的 东西 直接废了</p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>先写个博客</p>]]></content>
      
      
      <categories>
          
          <category> 每日一水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode第292场周赛</title>
      <link href="/2022/05/10/leetcode%E5%91%A8%E8%B5%9B/leetcode%E7%AC%AC292%E5%9C%BA%E5%91%A8%E8%B5%9B/"/>
      <url>/2022/05/10/leetcode%E5%91%A8%E8%B5%9B/leetcode%E7%AC%AC292%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="lc2264-字符串中最大的-3-位相同数字"><a href="#lc2264-字符串中最大的-3-位相同数字" class="headerlink" title="lc2264. 字符串中最大的 3 位相同数字"></a><a href="https://leetcode.cn/problems/largest-3-same-digit-number-in-string/">lc2264. 字符串中最大的 3 位相同数字</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">largestGoodInteger</span><span class="params">(string num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = num.<span class="built_in">size</span>();</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + <span class="number">2</span> &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">// 长度为3的子字符串相等</span></span><br><span class="line">            <span class="keyword">if</span>(num[i] == num[i+<span class="number">1</span>] &amp;&amp; num[i] == num[i+<span class="number">2</span>])&#123;</span><br><span class="line">                string ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                ss = ss + num[i] + num[i+<span class="number">1</span>] + num[i+<span class="number">2</span>];</span><br><span class="line">                res = <span class="built_in">max</span>(res, ss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc2265-统计值等于子树平均值的节点数"><a href="#lc2265-统计值等于子树平均值的节点数" class="headerlink" title="lc2265. 统计值等于子树平均值的节点数"></a><a href="https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/">lc2265. 统计值等于子树平均值的节点数</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">1</span>, sum = root-&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="keyword">auto</span> z = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            num += z.first;</span><br><span class="line">            sum += z.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">auto</span> z = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">            num += z.first;</span><br><span class="line">            sum += z.second;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum/num == root-&gt;val)&#123;</span><br><span class="line">            res++;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; root-&gt;val &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; &quot; &quot; &lt;&lt; sum &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;num, sum&#125;;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">averageOfSubtree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc2266-统计打字方案数"><a href="#lc2266-统计打字方案数" class="headerlink" title="lc2266. 统计打字方案数"></a><a href="https://leetcode.cn/problems/count-number-of-texts/">lc2266. 统计打字方案数</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> f[<span class="number">100001</span>];</span><br><span class="line">    <span class="type">int</span> v[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countTexts</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= i + <span class="number">3</span> &amp;&amp; j &lt;= <span class="number">100000</span>; j++)&#123;</span><br><span class="line">                f[j] += f[i];</span><br><span class="line">                f[j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= i + <span class="number">4</span> &amp;&amp; j &lt;= <span class="number">100000</span>; j++)&#123;</span><br><span class="line">                v[j] += v[i];</span><br><span class="line">                v[j] %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tempLen = <span class="number">1</span>, tempNum = s[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == tempNum)&#123;</span><br><span class="line">                tempLen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(tempNum == <span class="string">&#x27;7&#x27;</span> || tempNum == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                    res *= v[tempLen];</span><br><span class="line">                    res %= mod;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res *= f[tempLen];</span><br><span class="line">                    res %= mod;</span><br><span class="line">                &#125;</span><br><span class="line">                tempLen = <span class="number">1</span>;</span><br><span class="line">                tempNum = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最后还有一段没有算上</span></span><br><span class="line">        <span class="keyword">if</span>(tempNum == <span class="string">&#x27;7&#x27;</span> || tempNum == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            res *= v[tempLen];</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            res *= f[tempLen];</span><br><span class="line">            res %= mod;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="lc2267-检查是否有合法括号字符串路径"><a href="#lc2267-检查是否有合法括号字符串路径" class="headerlink" title="lc2267. 检查是否有合法括号字符串路径"></a><a href="https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/">lc2267. 检查是否有合法括号字符串路径</a></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dp[i][j][k] 表示 是否能合法到达 (i, j) 位置 且此时左括号 - 右括号数量为k </span></span><br><span class="line">    <span class="type">bool</span> dp[<span class="number">100</span>][<span class="number">100</span>][<span class="number">200</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasValidPath</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">// 看看此时 k 的情况 k最多是0-199</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">200</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][j][k])&#123;</span><br><span class="line">                        <span class="comment">// 向下走</span></span><br><span class="line">                        <span class="keyword">if</span>(i + <span class="number">1</span> &lt; m)&#123;</span><br><span class="line">                            <span class="type">int</span> l = k;</span><br><span class="line">                            <span class="keyword">if</span>(grid[i + <span class="number">1</span>][j] == <span class="string">&#x27;(&#x27;</span>) l++;</span><br><span class="line">                            <span class="keyword">else</span> l--;</span><br><span class="line">                            <span class="keyword">if</span>(l &gt;= <span class="number">0</span>) dp[i+<span class="number">1</span>][j][l] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 向右走</span></span><br><span class="line">                        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">                            <span class="type">int</span> l = k;</span><br><span class="line">                            <span class="keyword">if</span>(grid[i][j + <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span>) l++;</span><br><span class="line">                            <span class="keyword">else</span> l--;</span><br><span class="line">                            <span class="keyword">if</span>(l &gt;= <span class="number">0</span>) dp[i][j + <span class="number">1</span>][l] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode周赛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lc周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-10</title>
      <link href="/2022/05/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-10/"/>
      <url>/2022/05/10/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-10/</url>
      
        <content type="html"><![CDATA[<h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>一觉醒来8点半，吃了个早饭，9电多到了诚意，奴了把上周末的周赛，写到了10：50，准备水个博客</p><p>是不是该学编译原理了？</p><p>想到下午某源的课我就头疼，摊上这种老师真是倒了血霉了</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>看了会儿编译原理，终于看到P21了，还有3&#x2F;4没看，是不是要无了？<br>LL(1)文法感觉有点妙啊<br>这个什么FIRST集和FOLLOW集感觉有点不太熟练）还是摸的多了</p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>打了会儿球到9电多，投了两家公司的建立，在牛客网上又骚扰了几家公司<br>所以什么时候会开奖呢？<br>求华为和海康爆捞我</p><p>华泰啥时候能出一面结果啊）难受啊~~~~~~~~</p>]]></content>
      
      
      <categories>
          
          <category> 每日一水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022-05-09</title>
      <link href="/2022/05/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-09/"/>
      <url>/2022/05/09/%E6%AF%8F%E6%97%A5%E4%B8%80%E6%B0%B4/2022-05-09/</url>
      
        <content type="html"><![CDATA[<h2 id="早上"><a href="#早上" class="headerlink" title="早上"></a>早上</h2><p>又是个平凡的早晨，早上一睁眼就9点多了，胡乱吃了点早饭，滚回诚意后又又又摸了会小鱼，<br>看了会4月新番，表示周一更新的番剧还是太少了</p><p>云了会butterfly的配置</p><h2 id="中午"><a href="#中午" class="headerlink" title="中午"></a>中午</h2><p>吃到了美味的锅包肉</p><h2 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h2><p>上了架构师的课，评价是一个字没听，在听CY老师的编译原理，评价是一般，都在讲些DFA，NFA的东西，<br>有没有种可能是我还没看到新内容？</p><p>看了会butterfly的主题配置，配好了搜索，优化了主页，配好了加载动画等等</p><h2 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h2><p>小程序比赛的开发终于有了点效果，话说这个vant weapp的开发文档还能再简略点吗？<br>本来以为小程序开发的资料挺多的，一搜全是卖课的—-<br>基础不牢，地动山摇</p><p>一天的评价是：<b>寄</b></p>]]></content>
      
      
      <categories>
          
          <category> 每日一水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题配置</title>
      <link href="/2022/05/07/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/05/07/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/butterfly%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>为了方便运行代码查看实际效果，我们可以对package.json文件进行小修改<br>package.json里的scripts的每个属性就对应一个脚本<br>npm run xxx(属性名) 就是在执行对应的脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo generate&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clean&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;deploy&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo deploy&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;server&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hexo clean &amp;&amp; hexo generate &amp;&amp; hexo server&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>在根目录下的_config.yml文件修改菜单(menu)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="string">主页:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">Archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="string">标签:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">Categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-folder-open</span></span><br><span class="line">  <span class="string">List||fas</span> <span class="attr">fa-list:</span></span><br><span class="line">    <span class="attr">Music:</span> <span class="string">/music/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">    <span class="attr">Movie:</span> <span class="string">/movies/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-video</span></span><br><span class="line">  <span class="string">链接:</span> <span class="string">/link/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-link</span></span><br><span class="line">  <span class="string">关于:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fas</span> <span class="string">fa-heart</span></span><br></pre></td></tr></table></figure><p>代码高亮的主题</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="string">light</span> <span class="comment"># 代码的主题</span></span><br><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span> <span class="comment"># 代码是否可以拷贝</span></span><br><span class="line"><span class="attr">highlight_lang:</span> <span class="literal">true</span> <span class="comment"># 展示代码的语言</span></span><br><span class="line"><span class="attr">highlight_shrink:</span> <span class="literal">false</span> <span class="comment"># 代码展开和折叠 貌似现在默认可以有按钮</span></span><br><span class="line"><span class="attr">highlight_height_limit:</span> <span class="literal">false</span> <span class="comment"># 代码显示高度</span></span><br><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">false</span> <span class="comment">#代码的横向滚动条</span></span><br></pre></td></tr></table></figure><p>social里可以配置图标和链接</p><p>啊这）接下来貌似是要给文章加图片了 突然想起自己没有图床<br>赶紧选择picgo + github搞一波(为什么选这样？因为<b>白嫖</b>香啊)</p><p>github搜索picgo 进入里面的release 选择最新版本<br><a><a href="https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0">https://github.com/Molunerfinn/PicGo/releases/tag/v2.3.0</a></a><br>我是windows系统，所以直接下载exe后缀的<br>下载后直接安装即可</p><p>运行后在PicGo设置里勾选GitHub图床，我这里默认勾选了）</p><p>然后就是该去github建个仓库存放图片资源了</p><p>一下子就搭建完毕了）从现在可以开始弄图片了</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>评论系统搭建</title>
      <link href="/2022/05/07/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/"/>
      <url>/2022/05/07/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>有个图床真的舒服，随时随地爽</p><p>看了看别人的博客，感觉Twikoo和Valine都挺好看的 打算干脆直接搞个双评论系统)</p><h2>先配置下Valine吧</h2>首先打开LeanCloud官网 <a>https://console.leancloud.app/#/app</a> 选择国际版<p>注册后完善下信息 选择创建应用<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220507210426.png"></p><p>打开创建的应用 进行一些简单的配置</p><p>在设置的应用凭证里获取AppID Appkey等信息，写到_config.yml文件里<br><img src="https://cdn.jsdelivr.net/gh/Graham-ella/picgo/img/20220507211945.png"></p><p>重新启动，发现评论区有了</p><p>测试一下Toc功能</p><h2 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h2><p>sd</p><h3 id="heooo"><a href="#heooo" class="headerlink" title="heooo"></a>heooo</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
